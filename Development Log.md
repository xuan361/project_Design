**保持main分支，与发行版Releases一致，**

**dev应该是最新进展的最新开发记录**

**为实现可视化窗口，另开windows分支作为最新进展**


```
pseudo.py从program.txt中读取汇编语言并进行汇编，再输入到machine_code_output.txt
而用windows.py实现可视化操作窗口
```

#### **（2025.6.11改）**

应该已经99%了

##### 对上一次总结

- 优化ui：没啥好说的，一直在做，这次把寄存器区里面的寄存器代号加回去了，这样可读性更强；内存区加上了二进制数对应的十进制
- memory区  完善：这个其实没啥必要了，因为我其实好像也就需要那6位
- 行号区与代码区无法对齐：突然发现刚导入文件以及点击“重置“后是无法对齐的，但是如果点“汇编”又能自动对齐，很神奇
- 黄条的存在会抢占控制权：已解决
- 高亮黄条不符合预期，早了一行：目前高亮的是刚执行过的那一行
- 连续执行到最后不会终止，一直挂着：不用管，挂着就行
- 完善decode_and_excute：应该没问题



准备再重新做一个说明书：guide manual





（👇下面是以前的废话）





#### **（2025.6.10改）**

这几次改的都没有动readme，今天一起写了



目前模拟器能一圈跑下来（正确性有待检查）



在上次中提到的目标已经基本完成

加了一个内存区跳转功能，省得一直翻

program.txt微调 (debug一下)



基本上大任务都在等这个了，尽量这两天做完

后续小目标（小问题）：

- 优化ui （一直在做）
- memory区  完善   （优先显示有内容的地址，自动隐藏无内容的地址？）
- 行号区与代码区无法对齐（这个东西跟渲染系统有关系吗 不是很清楚  但是搞了好久一直弄不好，AI都没辙）
- 黄条的存在会抢占控制权
- 高亮黄条不符合预期，早了一行
- 连续执行到最后不会终止，一直挂着
- 完善decode_and_excute









#### **（2025.5.31改（2））**

接上方要求，修改之前的pseudo.py

> 数据逻辑有点问题，突然发现第257个字节对应的应该是129行，不是257行，因为一行是2个字节
>
> 就是机器码填充0的行数填充到128行，不用到256行了

因此将pseudo.py最后的  `if __name__`里面的那几个256全改成128即可



已经实现窗口的汉化

后续目标如下：

- 在代码中直接写好读取文件的地址，自动读取文件内容到代码区

- 在窗口的代码区自动识别 注释，指令，寄存器  并标上不同颜色

- 高亮标出当前的执行行

- 将寄存器区和内存区的窗口合并，并允许使用一个按钮进行切换，分别查看这两个区域

- 单步与执行的内容好像一样，都是点一下走一步

- 优化ui

- 内存区允许查看更多内存的内容

- 在代码区左侧自动用数字表明行数

- 断点

- 修改字体 增大字号

- #### **完善decode_and_excute**







#### **（2025.5.31改（1））**

**正在准备完善decode_and_execute函数**



> 刚完成的：
>
> 在保留原代码pseudo.py的前提下，让windows.py读取原代码中所需的函数，如opcode_map   reg_bin(reg_name)等，以减少windows.py的大小与长度







#### **（2025.5.30改）**

### **新目标：实现guide文件夹中 mp4  ppt中所演示的可视化窗口**

（新建了guide文件夹）

**新建windows.py以实现这个可视化操作窗口**



正在完善decode_and_execute函数









#### **（2025.5.24改）**



（因为其他指令在之前的汇编里都用过且似乎没有问题，所以我只检查了li的正确性并进行解决）

根据分析（lui处理前八位，addi处理后八位）

>     1010_0001_1011_1110
>
>     //    imm,    rd,  lui      (r11) = imm << 8  //此时r11 = 1010_0001_0000_0000
>
>     imm是8位的
>
>     0010_0001_0011_1100     
>
>     //imm   rs,  rd,  addi    (r3) = (r1) + 2     // 此时(r3) = 4, pc = 6
>
>     imm是4位的



lui处理前8位自然没有问题，但是addi的imm只有四位，可能无法全部处理后八位。

不过好在这三个 li 里

    li a0, 0x0100
    li a1, 0x1000
    li a2, 0x1006

最大的也不过是0x1006，后八位是06，即`0000_0110`,也用不到两个addi，也只不过是要求里的一个lui和一个addi

不过为了以防万一，还是要做好写一个lui和两个addi的准备（实际情况很复杂）

> 例如：
>
> li rd, 0       -> lui rd, 0x0 (1條)
>
> li rd, 5       -> lui rd, 0x0; addi rd, rd, 5 (2條)
>
> li rd, 0x20    -> lui rd, 0x0; addi rd, rd, 2 (2條) (0x20 -> middle_4_bits=2, lower_4_bits=0)
>
> li rd, 0x25    -> lui rd, 0x0; addi rd, rd, 2; addi rd, rd, 5 (3條)
>
> li rd, 0x1000  -> lui rd, 0x10 (1條) (middle和lower都為0)
>
> li rd, 0x1006  -> lui rd, 0x10; addi rd, rd, 6 (2條) (middle為0, lower為6)
>
> li rd, 0x1020  -> lui rd, 0x10; addi rd, rd, 2 (2條) (middle為2, lower為0)
>
> li rd, 0x1025  -> lui rd, 0x10; addi rd, rd, 2; addi rd, rd, 5 (3條)

#这个标在expand_pseudo_instructions()函数里 ‘ li ’段的最后









### **（2025.5.23改）**

目前已经能够实现上次的目标：

```
前256行写机器码（空行全部补0），从257行开始写由 _data_lma 输入的数字的8位二进制数，每行写两个，格式与之前的16位机器码保持一致，都是 XXXX_XXXX_XXXX_XXXX
```

同时将输入文件改回program.txt，原先的program.txt现更改为program - 3.txt



预计前256行里应该有23行机器码`	（（1 + 1 + 2）+ 5 + 1 + 11 + 1 + 1 = 23）`

但program.txt的最后一行机器指令    jal r0, end_sort 刚好对应的机器码是0000_0000_0000_0000,与后面填0的一致，所以可能只有前22行非0



> （但是可能还有个问题：第23行与后面的形式一样但含义不同，是否会在读取时发生问题）



亟需解决：pseudo.py中对li的逻辑定义有误，正在更改









#### **（2025.5.22改）**

NEW    提出新目标：实现（冒泡）排序

新的汇编语言写在programm.txt里面了，还没有检查输出结果正确性

```
// 0    rom
// 1000 ram
// 2000 led
// 3000 数码管
start:  //把 data section 从 flash(ROM) 搬运到 ram 中
    li a0, 0x100    // flash(ROM) 的起始地址a0
    li a1, 0x1000  // ram 的起始地址a1 if number > 256 then lui a1, 0x10,  addi a1, a1, 0x00
    li a2, 0x1006    // ram 的结束地址a2  lui a1, 0x10,  addi a1, 0x06

move_loop:             /// 循环移动数据，数据通过a3寄存器进行传递
    lb a3, 0(a0)
    sb a3, 0(a1)
    addi a0, a0, 1
    addi a1, a1, 1
    ble a1, a2, move_loop

begin:
    addi a3, a1, 0  //头指针a3


outer_loop1:
    addi a4, a3, 1  //尾指针a4
    inner_loop1:
        lb a5, 0(a3)
        lb a6, 0(a4)
        ble a5, a6, no_swap
        sb a6, 0(a3)
        sb a5, 0(a4)
        no_swap:
            addi a4, a4, 1
            ble a4, a2, inner_loop1
    addi a3, a3, 1
    ble a3, a2, outer_loop1_mid
    jal  outer_loop1_out

outer_loop1_mid:
    jal  outer_loop1

outer_loop1_out:

end_sort:
    jal r0, end_sort

_data_lma:
    .byte 13, 12, 7, 12, 9, 11       //内存空间为8位
```



```
// 0    rom
// 1000 ram
// 2000 led
// 3000 数码管
这几行表示起始地址，之后也会用到后面的
```



目前正在追求实现：前256行写机器码（空行全部补0），从257行开始写由 _data_lma 输入的数字的8位二进制数，每行写两个，格式与之前的16位机器码保持一致，都是 XXXX_XXXX_XXXX_XXXX





### **（2025.5.12改（final））**

（那边的仿真已经成功了，现在应该就是最终版了）

修改了inner_loop ,outter_loop,start,这三个标签对应的跳转指令ble,beq ,jal的跳转逻辑。



例，如果标签 inner_loop 指向指令 x，那么跳转实际目标是指令 x之后的下一条指令

要把原始标签指向的地址索引 +1 作为新的目标地址索引

造成输出的16位机器码里会有一个部分比原先加1



但是按照之前，inner_loop不对应机器码，会造成死循环，一直重新赋值为0然后加1

（算了算了，反正其实我也不太能完全理解，感谢ai，在此特别鸣谢Gemini，我这样的fvv什么时候会被取代呢？）



对于ble 和beq， 输出机器码结构是：rt  rs  offset  opcode  ,那应该就是这个offset,第三个位置加1

![image-20250512200825039](C:\Users\32188\AppData\Roaming\Typora\typora-user-images\image-20250512200825039.png)

对于jal，结构是：imm(8位)  rt  opcode，那应该就是imm，第一个位置加1

 ![image-20250512200847564](C:\Users\32188\AppData\Roaming\Typora\typora-user-images\image-20250512200847564.png)



好了，这下的话看来仿真能成功了，特别鸣谢wzx，你是我的神

![20a35a4dfb05c4ba7feee34d424149b](D:\WeChat\新建文件夹\WeChat Files\wxid_ef16da52vn3122\FileStorage\Temp\20a35a4dfb05c4ba7feee34d424149b.png)





```
同时，为追求文件大小最小化，删除多余文件

同时保存以前用过的（现在仍可使用）的汇编语言于program - X.txt中（共两个）做备
```





#### **（2025.5.12 更）**

应该快要结束了，存一下档，本来应该是这个档或者上个档来做第三档的）

sb指令那里对应输出的机器码位置次序不对

![image-20250512200520881](C:\Users\32188\AppData\Roaming\Typora\typora-user-images\image-20250512200520881.png)





#### **（2025.5.8 改）**

添加了识别 start 标识符以及 inner_loopX , outer_loopX  (X一般代表数字，一个文件中可能有多个 inner_loop 或outer_loop)

特别注意输入的指令应当形如        lui a1, 0x20

即       “ 指令 + [空格] + rt + [逗号“，”] + [空格] + imm “

注意指令与后面内容有空格隔开，而后面 rt  rs  imm之间即便有逗号也要有空格分割（即便start , inner_loop , outer_loop也是一样）



把上版的输入内容存为      program - 副本.txt     

把之前写的没一点用的东西先删了



(例，输入)program.txt



```
addi a0, r0, 1   //a0 = 1,是后面复制到led对应内存区域的值
lui a1, 0x20     //a1 = 0x2000,是led的内存起始地址
lui a2, 0x04    //外层循环数
lui a3, 0x61   //内层循环数
start:
lb a4, 0(r0)     //a4是外层计数器
outer_loop1:
lb a5, 0(r0)     //a5是内层计数器
inner_loop1:
addi a5, a5, 1
ble a5, a3, inner_loop1
addi a4, a4, 1
beq a4, a2, outer_loop1
sb a0, 0(a1)
sb r0, 1(a1)
sb r0, 2(a1)
sb r0, 3(a1)

lb a4, 0(r0)     //a4是外层计数器
outer_loop2:
lb a5, 0(r0)     //a5是内层计数器
inner_loop2:
addi a5, a5, 1
ble a5 ,a3, inner_loop2
addi a4, a4, 1
beq a4, a2, outer_loop2
sb r0, 0(a1)
sb a0, 1(a1)
sb r0, 2(a1)
sb r0, 3(a1)

lb a4, 0(r0)     //a4是外层计数器
outer_loop3:
lb a5, 0(r0)     //a5是内层计数器
inner_loop3:
addi a5, a5, 1
ble a5, a3, inner_loop3
addi a4, a4, 1
beq a4, a2, outer_loop3
sb r0, 0(a1)
sb r0, 1(a1)
sb a0, 2(a1)
sb r0, 3(a1)

lb a4, 0(r0)     //a4是外层计数器
outer_loop4:
lb a5, 0(r0)     //a5是内层计数器
inner_loop4:
addi a5, a5, 1
ble a5, a3, inner_loop4
addi a4, a4, 1
beq a4, a2, outer_loop4
sb r0, 0(a1)
sb r0, 1(a1)
sb r0, 2(a1)
sb a0, 3(a1)
jal r1, start


```



(例，输出)machine_code_output.txt



```
0001_0000_0011_1100
0010_0000_0100_1110
0000_0100_0101_1110
0110_0001_0110_1110
0000_0000_0111_0100
0000_0000_1000_0100
0001_1000_1000_1100
0110_1000_1110_0011
0001_0111_0111_1100
0101_0111_1011_0010
0000_0100_0011_0110
0001_0100_0000_0110
0010_0100_0000_0110
0011_0100_0000_0110
0000_0000_0111_0100
0000_0000_1000_0100
0001_1000_1000_1100
0110_1000_1110_0011
0001_0111_0111_1100
0101_0111_1011_0010
0000_0100_0000_0110
0001_0100_0011_0110
0010_0100_0000_0110
0011_0100_0000_0110
0000_0000_0111_0100
0000_0000_1000_0100
0001_1000_1000_1100
0110_1000_1110_0011
0001_0111_0111_1100
0101_0111_1011_0010
0000_0100_0000_0110
0001_0100_0000_0110
0010_0100_0011_0110
0011_0100_0000_0110
0000_0000_0111_0100
0000_0000_1000_0100
0001_1000_1000_1100
0110_1000_1110_0011
0001_0111_0111_1100
0101_0111_1011_0010
0000_0100_0000_0110
0001_0100_0000_0110
0010_0100_0000_0110
0011_0100_0011_0110
1101_0111_0001_0000


```

经Gemini检验应当是无误的





#### **（👇下面是以前的废话（👇下面是以前的废话））**

目前可以使用添加的伪指令la li bge j

(例，输入)program.txt

lui a4, 0x8       // 0x800 * 0x8000 = 0x400_0000
outer_loop:
lui a2, 0x40      // 0x4000 * 2 = 0x8000
inner_loop:
addi a1, a1, 1
ble a1, a2, inner_loop
addi a3, a3, 1
ble a3, a4, outer_loop



![image-20250425185405539](C:\Users\32188\AppData\Roaming\Typora\typora-user-images\image-20250425185405539.png)

![image-20250425190403673](C:\Users\32188\AppData\Roaming\Typora\typora-user-images\image-20250425190403673.png)







#### **（👇下面是以前的废话（👇下面是以前的废话））**

(例，输出)machine_code_output.txt

```
0000_1000_0111_1110
0100_0000_0101_1110
0001_0100_0100_1100
0101_0100_1110_0011
0001_0110_0110_1100
0111_0110_1011_0011
```





> 
>
> (例)
>
> （输入）program.txt
>
> jal r1, 0
> jalr r1, r3, 6
> addi r3, r1, 2
> subi r4, r1, -2
> beq r3, r4, -6
> ble r3, r5, 0
> add r5, r3, r4
> sub r6, r3, r4
> sb r5, 2(r6)
> sw r5, 4(r6)
> lb r7, 4(r6)
> lw r8, 2(r6)
> and r9, r5, r6
> or r10, r5, r6
> lui r11, 0xA1
>
> 
>
> （输出）machine_code_output.txt
>
> 0000_0000_0001_0000
> 0110_0011_0001_0001
> 0010_0001_0011_1100
> 1110_0001_0100_1101
> 0100_0011_1010_0010
> 0101_0011_0000_0011
> 0100_0011_0101_1000
> 0100_0011_0110_1001
> 0010_0110_0101_0110
> 0100_0110_0101_0111
> 0100_0110_0111_0100
> 0010_0110_1000_0101
> 0110_0101_1001_1010
> 0110_0101_1010_1011
> 1010_0001_1011_1110







## 4、给定一个汇编程序，制定汇编语法规则，写一个软件将汇编指令翻译成机器指令。再根据汇编语法规则，写一个整数排序程序。

16个16位通用寄存器：r0-r15，其中r0为恒0寄存器，r1为返回地址寄存器ra，r2为栈指针寄存器sp，其余为运算寄存器a0-a12(即r3-r15)，其中a0还作为保存函数参数或返回值。

jal->addi->subi->beq->jalr->ble->add->sub->sb->sw->lb->lw->and->or->andi->ori



```
0000_0100_0001_0000
```

  //  imm(4),   rd,  jal    (r1) = pc + 2, pc = pc + 4  //此时(r1) = 2, pc =4



    0110_0011_0001_0001     (r1) = pc + 2, pc = (r3) + 6  //此时(r1) = 4, pc = 10

  //imm,  rs,  rd,  jalr



    0010_0001_0011_1100     

  //imm   rs,  rd,  addi    (r3) = (r1) + 2     // 此时(r3) = 4, pc = 6



    1110_0001_0100_1101

  //imm,  rs,  rd,  subi    (r4) = (r1) - (-2)   //此时(r4) = 4, pc = 8



    0100_0011_1010_0010     (r3) == (r4) ? pc = pc - 6 : pc = pc + 2  //此时pc = 2

  //rt,  rs, offset, beq
    

    0101_0011_0000_0011

  //rt,  rs, offset, ble    (r3) <= (r5) ? pc = pc  : pc = pc + 2     // pc = 12
    

    0100_0011_0101_1000

  //rt,   rs,  rd,  add    (r5) = (r3) + (r4)   //此时(r5) = 8
    

    0100_0011_0110_1001

  //rt,   rs,  rd,  sub    (r6) = (r3) - (r4)   //此时(r6) = 0



    0101_0110_0010_0110

  //rt,  rs,  imm,  sb      ad = (r6) + 2   (ad) = (r5)     //此时存储单元[2] = 8



    0101_0110_0100_0111

  //rt,  rs,  imm,  sw      ad = (r6) + 4   (ad) = (r5)     //此时存储单元[4] = 8   存储单元[5] = 0   

 

    0100_0110_0111_0100

  //imm,  rs,  rd,  lb      ad = (r6) + 4   (r7) = (ad)     //此时(r7) = 0000_1000



    0010_0110_1000_0101

  //imm,  rs,  rd,  lw      ad = (r6) + 2   (r8) = (ad)     //此时(r8) = 0000_1000_0000_0000



    0110_0101_1001_1010

  //rt,   rs,  rd,  and    (r9) = (r5) && (r6)  //此时r9 = 0



    0110_0101_1010_1011

  //rt,   rs,  rd,  or     (r10) = (r5) || (r6)  //此时r10 = 8 即(0000_0000_0000_1000)



    1010_0001_1011_1110

  //    imm,    rd,  lui      (r11) = imm << 8  //此时r11 = 1010_0001_0000_0000